# 数据结构期末八股
# 绪论

## 一. 单选题

1. **题目**: 在数据结构中，与所使用的计算机无关的是数据的（ ） 结构。

   - A. 存储
   - B. 逻辑
   - C. 逻辑和存储
   - D. 物理
     **正确答案**: B
     **解析**: 数据的逻辑结构是指数据元素之间的逻辑关系，与计算机无关。而存储结构和物理结构则与计算机的存储方式密切相关。

2. **题目**: 以下算法的时间复杂度是( )。 

   ```java
   public void A(){ 
       for ( int i=n; i>=1; i=i/2) 
           System.out.print(i); 
   }
   ```

   - A. O(<img style="vertical-align: middle; filter: invert(0);" class="ans-edrawmath-moudle" data="%22%5C%5C%5B%7Bn%7B%5C%5Cmathop%7B%7Blog%7D%7D%5C%5Cnolimits_%7B%7B2%7D%7Dn%7D%7D%5C%5C%5D%22" src="https://p.ananas.chaoxing.com/star3/origin/bafd75d3bca61632b38cff6bd094de42.png" data-original="https://p.ananas.chaoxing.com/star3/origin/bafd75d3bca61632b38cff6bd094de42.png">)
   - B. O(<img style="vertical-align: middle; filter: invert(0);" class="ans-edrawmath-moudle" data="%22%5C%5C%5B%7B%7B%5C%5Cmathop%7B%7B%20%5C%5Ctext%7Blog%7D%20%7D%7D%5C%5Cnolimits_%7B%7B2%7D%7Dn%7D%7D%5C%5C%5D%22" src="https://p.ananas.chaoxing.com/star3/origin/32822e19e9491d99ff4366dee563b380.png" data-original="https://p.ananas.chaoxing.com/star3/origin/32822e19e9491d99ff4366dee563b380.png">)
   - C. O(1)
   - D. O(n)
     **正确答案**: B
     **解析**: 该算法的时间复杂度为 O(log₂n)，因为每次循环 i 都减半，循环次数与 log₂n 成正比。

3. **题目**: 算法分析的主要任务之一是分析（ ）

   - A. 算法的功能是否符合设计要求
   - B. 算法中是否存在错误语法
   - C. 算法的执行时间和问题规模之间的关系
   - D. 算法是否具有较好的可读性
     **正确答案**: C
     **解析**: 算法分析的主要任务是分析算法的执行时间和问题规模之间的关系，以评估算法的效率。

4. **题目**: 在数据结构中,依赖于计算机的是( )。

   - A. 逻辑结构
   - B. 逻辑结构和存储结构
   - C. 存储结构
   - D. 都不是
     **正确答案**: C
     **解析**: 存储结构依赖于计算机的存储方式，而逻辑结构与计算机无关。

5. **题目**: 以下数据结构中,( )是非线性结构

   - A. 字符串
   - B. 树
   - C. 栈
   - D. 队列
     **正确答案**: B
     **解析**: 树是一种非线性数据结构，而字符串、栈和队列都是线性结构。

6. **题目**: 算法的时间复杂度与什么有关?( )

   - A. 程序设计语言
   - B. 编译程序质量
   - C. 计算机硬件性能
   - D. 问题规模
     **正确答案**: D
     **解析**: 算法的时间复杂度主要与问题规模有关，表示算法执行时间随问题规模增长的变化趋势。

7. **题目**: 在以下的叙述中,正确的是( )。

   - A. 线性表的顺序存储结构优于链表存储结构
   - B. 线性表的链式存储结构适用于频繁插入/删除数据元素的情况
   - C. 线性表的顺序存储结构适用于频繁插入/删除数据元素的情况
   - D. 线性表的链表存储结构优于顺序存储结构
     **正确答案**: B
     **解析**: 链式存储结构适用于频繁插入/删除数据元素的情况，因为它的插入和删除操作时间复杂度为 O(1)，而顺序存储结构则需要 O(n)。

8. **题目**: 数据结构中处理的数据一般具备某种内在联系，这是指（ ）。

   - A. 数据项和数据项之间存在某种关系
   - B. 元素和元素之间存在某种关系
   - C. 数据和数据之间存在某种关系
   - D. 元素内部具有某种结构
     **正确答案**: B
     **解析**: 数据结构中处理的数据一般具备某种内在联系，通常是指元素和元素之间存在某种关系。

9. **题目**: 以下代码的时间复杂度是( )。

   ```java
   n=100;  
   while (n>0)  
       n--;
   ```

   - A. 1
   - B. O(n)
   - C. O(1)
   - D. O(100)
     **正确答案**: C
     **解析**: 因为 n 的值是一个确定的常数，所以时间复杂度为 O(1)。

10. **题目**: 算法分析的目的是( )。

    - A. 分析算法的效率以求改进
    - B. 分析算法的易读性和文档性
    - C. 研究算法中输入和输出的关系
    - D. 找出数据结构的合理性
      **正确答案**: A
      **解析**: 算法分析的主要目的是分析算法的效率，以便进行改进。

11. **题目**: 以下算法的时间复杂度是( )。

    ```java
    int i=n;  
    while ( (i-1)*(i-1)>0) //n为大于1的整数
        i--;
    ```

    - A. O(n)
    - B. O(<img style="vertical-align: middle; filter: invert(0);" class="ans-edrawmath-moudle" data="%22%5C%5C%5B%7Bn%5C%5Cmathop%7B%7B%7D%7D%5C%5Cnolimits%5E%7B%7B3%7D%7D%7D%5C%5C%5D%22" src="https://p.ananas.chaoxing.com/star3/origin/bfba419d9788e3f47d1a7cce5b6e4730.png" data-original="https://p.ananas.chaoxing.com/star3/origin/bfba419d9788e3f47d1a7cce5b6e4730.png">）
    - C. O(<img style="vertical-align: middle; filter: invert(0);" class="ans-edrawmath-moudle" data="%22%5C%5C%5B%7Bn%5C%5Cmathop%7B%7B%7D%7D%5C%5Cnolimits%5E%7B%7B2%7D%7D%7D%5C%5C%5D%22" src="https://p.ananas.chaoxing.com/star3/origin/9a0ba6bb7d647653225c502bb68d094e.png" data-original="https://p.ananas.chaoxing.com/star3/origin/9a0ba6bb7d647653225c502bb68d094e.png">)
    - D. O(n /2)
      **正确答案**: A
      **解析**: 该算法的时间复杂度为 O(n)，因为循环次数与 n 成正比。

12. **题目**: 在计算机的存储器中表示时，逻辑上相邻的两个元素对应的物理地址也是相邻的，这种存储结构称为（ ）。

    - A. 链式存储结构
    - B. 以上都正确
    - C. 逻辑结构
    - D. 顺序存储结构
      **正确答案**: D
      **解析**: 顺序存储结构中，逻辑上相邻的元素在物理地址上也是相邻的。

13. **题目**: 以下算法的时间复杂度是( )。

    ```java
    for(i=0, j=0; i＜n; i++)  
        c[i][j]=i+j;  
    ```

    - A. O(1)
    - B. O(n)
    - C. O(logn)
    - D. O(n<sup>2</sup>)
      **正确答案**: B
      **解析**: 该算法的时间复杂度为 O(n)，因为循环次数与 n 成正比。

14. **题目**: 数据结构在计算机中的表示称为数据的( )。

    - A. 存储结构
    - B. 抽象数据结构
    - C. 顺序结构
    - D. 逻辑结构
      **正确答案**: A
      **解析**: 数据结构在计算机中的表示称为存储结构，它描述了数据在计算机中的存储方式。

## 二. 填空题

15. **题目**: 数据的基本单位是____,最小单位是____。
    **正确答案**: 
    - (1) 数据元素
    - (2) 数据项
      **解析**: 数据的基本单位是数据元素，最小单位是数据项。

16. **题目**: 按照结点之间的逻辑关系,数据结构可以分为____和____两大类。
    **正确答案**: 
    - (1) 线性;线性结构
    - (2) 非线性;非线性结构
      **解析**: 数据结构按照结点之间的逻辑关系可以分为线性结构和非线性结构两大类。

17. **题目**: 数据结构研究的3个方面分别是数据的____、数据的____和数据的操作。
    **正确答案**: 
    - (1) 逻辑结构;存储结构
    - (2) 存储结构;逻辑结构
      **解析**: 数据结构研究的3个方面分别是数据的逻辑结构、存储结构和数据的操作。

## 三. 判断题

18. **题目**: 逻辑结构相同的数据,可以采用多种不同的存储方法。
    **正确答案**: 对
    **解析**: 逻辑结构相同的数据可以采用多种不同的存储方法，如顺序存储、链式存储等。

19. **题目**: 算法一般应该具有以下5个性质:有穷性、确定性、有效性、输入、输出。
    **正确答案**: 对
    **解析**: 算法应具备有穷性、确定性、有效性、输入和输出这5个基本性质。

20. **题目**: 程序不等于算法。
    **正确答案**: 对
    **解析**: 程序是算法的具体实现，但程序不等于算法，算法是解决问题的步骤，而程序是算法的代码实现。

# 线性表

## 一. 单选题

1. **链式存储中,元素之间的逻辑关系是通过什么表示的。**
   - A. 存储位置
   - B. 附加指针
   - C. 数组下标
   - D. 逻辑结构
     **正确答案:** B  
     **解析:** 链式存储中，元素之间的逻辑关系是通过**附加指针**来表示的。每个元素包含一个指向下一个元素的指针，通过这些指针将元素串联起来。

2. **将两个各有n个元素的递增有序顺序表归并为一个有序顺序表，其最少的比较次数是（ ）。**
   - A. n
   - B. n-1
   - C. 2n-1
   - D. 2n
     **正确答案:** A  
     **解析:** 当两个有序顺序表的最小元素分别位于各自表的第一个位置时，只需要比较n次即可完成归并。

3. **若数组int A[][]=new int[6][7]; 它的的每个元素占用5个字节，将其按照行优先方式存储在起始地址为1000的内存单元中，那么元素A[3][5]的地址为（）。**
   - A. 1180
   - B. 1130
   - C. 1210
   - D. 1205
     **正确答案:** B  
     **解析:** 按行优先存储，元素A[3][5]的地址计算为：1000 + (3 * 7 + 5) * 5 = 1000 + 26 * 5 = 1130。

4. **以下数据结构中,可以通过首元素在内存中的存储位置和元素存储空间大小而计算出每一个元素在内存空间存储位置的是( )。**
   - A. 数组
   - B. 二叉树
   - C. 图
   - D. 链表
     **正确答案:** A  
     **解析:** **数组**的元素在内存中是连续存储的，因此可以通过首元素的地址和元素的大小计算出任意元素的地址。

5. **线性表采用链表存储时，存放所有元素的结点地址（ ）**
   - A. 连续与否均可以。
   - B. 部分地址必须是连续的
   - C. 必须是连续的
   - D. 一定是不连续的
     **正确答案:** A  
     **解析:** 链表中的结点地址可以是**连续或不连续**的，因为链表通过指针来连接各个结点，不要求物理上的连续存储。

6. **对于下图所示的单链表,下列表达式值为真的是( )。**
   ![单链表图](https://p.ananas.chaoxing.com/star3/origin/33d1b5e0fad0538172c219f9da1e5910.png)
   - A. head.next.next==p1
   - B. p1.next.next=='E'
   - C. P1.next==’D’
   - D. P1.data==’D’
     **正确答案:** A  
     **解析:** 根据链表的结构，`head.next.next`指向的是`p1`结点，因此表达式`head.next.next==p1`为真。

7. **已知一个长度为n的单链表是递增有序的，所有结点的值不相同，以下叙述中正确的是（ ）。**
   - A. 插入一个结点使之有序的算法的时间复杂度为O(1)
   - B. 删除最大值结点使之有序的算法的时间复杂度为O(1)
   - C. 以上都不对
   - D. 找最小值结点的算法的时间复杂度为O(1)
     **正确答案:** D  
     **解析:** 由于链表是递增有序的，**最小值结点**就是链表的第一个结点，因此查找最小值的时间复杂度为O(1)。

8. **顺序表具有的优点有( )。**
   - A. 事先不需要估计存储空间
   - B. 便于插入、删除操作
   - C. 可随机存取元素
   - D. 比链表优越
     **正确答案:** C  
     **解析:** 顺序表的优点是**可随机存取元素**，即可以通过下标直接访问任意位置的元素。

9. **在有n个结点的顺序表中做插入运算,需平均移动结点的数目为( )。**
   - A. (n+1)/2
   - B. n
   - C. (n-1)/2
   - D. n/2
     **正确答案:** D  
     **解析:** 在顺序表中插入一个元素，平均需要移动**n/2**个元素。

10. **在长度为n的（ ）上，删除尾结点的时间复杂度为O(1)。**
    - A. 循环单链表
    - B. 双向链表
    - C. 循环双链表
    - D. 单链表
      **正确答案:** C  
      **解析:** **循环双链表**可以通过尾结点的前驱指针快速找到尾结点的前驱，因此删除尾结点的时间复杂度为O(1)。

11. **若某线性表最常用的操作是查找序号为i的元素和在末尾插入元素，则选择（ ）结构最节省时间。**
    - A. 带头结点的循环双链表
    - B. 顺序表
    - C. 单链表
    - D. 带尾结点的循环单链表
      **正确答案:** B  
      **解析:** **顺序表**支持随机访问，查找序号为i的元素的时间复杂度为O(1)，且在末尾插入元素的时间复杂度也为O(1)。

12. **在含有n个元素的顺序表中，算法的时间复杂度为O(1)的是（ ）。**
    - A. 访问第i个元素(0<=i<=n-1)和求第i个元素(1<=i<=n-1)的前驱元素
    - B. 在第i个元素(0<=i<=n-1)后插入一个新元素
    - C. 删除第i个元素(0<=i<=n-1)
    - D. 将n个元素从小到大排序
      **正确答案:** A  
      **解析:** 顺序表支持**随机访问**，访问第i个元素和求其前驱元素的时间复杂度均为O(1)。

13. **链表不具备的特点是（ ）。**
    - A. 不必实现估计存储空间
    - B. 所需空间与其长度成正比
    - C. 插入、删除不需要移动结点
    - D. 可随机访问任意结点
      **正确答案:** D  
      **解析:** 链表**不支持随机访问**，访问任意结点需要从头结点开始遍历。

14. **在线性表中,若经常要存取第i个元素及其前驱,则宜采用( )的存储方式。**
    - A. 不带头结点的单链表
    - B. 带头结点的单链表
    - C. 单向循环链表
    - D. 顺序表
      **正确答案:** D  
      **解析:** **顺序表**支持随机访问，存取第i个元素及其前驱的时间复杂度均为O(1)。

15. **已知两个长度分别为m和n的递增单链表，若将它们合并为一个长度为m+n的递减单链表，则最好情况下的时间复杂度是（ ）**
    - A. O(mn)
    - B. O(m)
    - C. O(m+n)
    - D. O(n)
      **正确答案:** C  
      **解析:** 合并两个递增链表为递减链表，时间复杂度为**O(m+n)**，因为需要遍历两个链表的所有元素。

16. **以下关于链表的叙述中不正确的是（ ）。**
    - A. 逻辑上相邻的元素物理上不必相邻
    - B. 可以根据头结点地址直接计算出第i个结点的地址
    - C. 结点中除元素值外还包括指针成员，因此存储密度小于顺序存储结构
    - D. 插入、删除运算操作方便，不必移动结点
      **正确答案:** B  
      **解析:** 链表**不支持随机访问**，不能根据头结点地址直接计算出第i个结点的地址。

17. **在单链表指针为p的结点之后插入指针为s的结点,正确的操作是:()**
    - A. p.next = s; s.next = p.next;
    - B. s.next = p.next;p.next = s;
    - C. p.next = s; p.next = s.next;
    - D. p.next = s.next; p.next = s;
      **正确答案:** B  
      **解析:** 正确的插入操作是先将`s.next`指向`p.next`，再将`p.next`指向`s`，即`s.next = p.next; p.next = s;`。

18. **线性表若采用顺序表作为存储结构时,要求内存中可用存储单元的地址( )。**
    - A. 连续或不连续都可以
    - B. 一定是不连续的
    - C. 必须是连续的
    - D. 部分地址必须是连续的
      **正确答案:** C  
      **解析:** 顺序表要求内存中可用存储单元的地址**必须是连续的**。

19. **求单链表中当前结点p的后继和前驱的时间复杂度分别是（ ）。**
    - A. O(n)和O(1)
    - B. O(n)和O(n)
    - C. O(1)和O(1)
    - D. O(1)和O(n)
      **正确答案:** D  
      **解析:** 单链表中，求当前结点p的**后继**的时间复杂度为O(1)，但求**前驱**需要从头结点开始遍历，时间复杂度为O(n)。

20. **线性表若采用链式存储结构时,要求内存中可用存储单元的地址( )。**
    - A. 部分地址必须是连续的
    - B. 必须是连续的
    - C. 一定是不连续的
    - D. 连续不连续都可以
      **正确答案:** D  
      **解析:** 链式存储结构中，内存中可用存储单元的地址**可以连续或不连续**。

21. **对于单链表存储结构，以下说法中错误的是（ ）。**
    - A. 单链表必须带有头结点
    - B. 一个结点的数据成员用于存放线性表中的一个数据元素。
    - C. 一个结点的指针成员用于指向下一个数据元素的结点
    - D. 单链表中的所有结点可以连续存放也可以不连续存放。
      **正确答案:** A  
      **解析:** 单链表**不一定必须带有头结点**，头结点只是为了方便操作。

22. **在一个单链表中的s和t两个结点之间插入一个新的结点p,则修改链的Java语句序列是()。**
    - A. s.next=p; p.next=t.next
    - B. p.next=t；s.next=p;
    - C. s.next=p; p.next=s.next
    - D. p.next=t; s.next=p.next
      **正确答案:** B  
      **解析:** 正确的插入操作是先将`p.next`指向`t`，再将`s.next`指向`p`，即`p.next=t; s.next=p;`。

23. **以下关于顺序表的叙述中正确的是（ ）。**
    - A. 顺序表的优点是存储密度大且插入、删除运算的效率高
    - B. 顺序表中的所有元素可以连续存放也可以不连续存放
    - C. 在含n个元素的顺序表中查找序号为i的元素的事件复杂度为O(n)
    - D. 顺序表的优点是具有随机存取特性
      **正确答案:** D  
      **解析:** 顺序表的优点是**具有随机存取特性**，即可以通过下标直接访问任意位置的元素。

24. **有一个长度为n(n>1)的带头结点的单链表，另设有尾指针r（指向尾结点），执行（ )操作与链表的长度有关。**
    - A. 在单链表的尾结点后插入一个新结点。
    - B. 删除单链表中的首结点
    - C. 在单链表的首结点前插入一个新结点
    - D. 删除单链表中的尾结点
      **正确答案:** D  
      **解析:** 删除单链表中的**尾结点**需要从头结点开始遍历到倒数第二个结点，因此与链表的长度有关。

25. **线性表的链式存储结构与顺序存储结构相比，其优点是（ ）。**
    - A. 节省存储空间
    - B. 所有操作的算法实现简单
    - C. 便于随机存取
    - D. 便于插入和删除元素
      **正确答案:** D  
      **解析:** 链式存储结构的优点是**便于插入和删除元素**，因为不需要移动其他元素。

## 二. 填空题

26. **在顺序表中的第i(0≤i≤n-1)个位置之前插入一个新的数据元素,会引起____个数据元素的移动操作。**
      **正确答案:** n-i  
      **解析:** 在顺序表中插入一个元素，需要将第i个位置及其后的所有元素向后移动，因此需要移动**n-i**个元素。

27. **线性表中有且仅有一个开始结点和终端结点,除开始结点和终端结点外,其他每个数据元素有且仅有一个____,有且仅有一个____。**
      **正确答案:** 前驱；后继  
      **解析:** 线性表中，除开始结点和终端结点外，每个元素有且仅有一个**前驱**和一个**后继**。

28. **在一个长度为n的顺序表中第i个元素(1<= i <=n)之前插入一个元素时,需向后移动____个元素。**
      **正确答案:** n-i+1  
      **解析:** 在顺序表中插入一个元素，需要将第i个位置及其后的所有元素向后移动，因此需要移动**n-i+1**个元素。

29. **对于带头结点head的单向循环链表,如果用p表示当前正在被访问的结点。那么判断到了链表最后一个结点的语句是____。**
      **正确答案:** p.next==head  
      **解析:** 在单向循环链表中，最后一个结点的`next`指针指向头结点，因此判断当前结点是否为最后一个结点的条件是`p.next==head`。

30. **带头结点head的单向链表L判定为空的条件是 。**
      **正确答案:** L.head.next == NULL  
      **解析:** 带头结点的单向链表为空的条件是头结点的`next`指针为`NULL`，即`L.head.next == NULL`。

31. **对于一个具有n个结点的单链表,在已知的结点 p后插入一个新结点的时间复杂度为____。**
      **正确答案:** O(1)  
      **解析:** 在已知结点p后插入一个新结点，只需要修改p的`next`指针，时间复杂度为**O(1)**。

## 三. 判断题

32. **分配给顺序表的内存单元地址必须是连续的。**
      **正确答案:** 对  
      **解析:** 顺序表要求内存单元地址**必须是连续的**，因为顺序表通过下标直接访问元素，连续存储才能保证随机访问的效率。

33. **在顺序表中取出第i个元素所花费的时间与i成正比。**
      **正确答案:** 错  
      **解析:** 顺序表支持**随机访问**，取出第i个元素的时间复杂度为O(1)，与i的大小无关。

34. **链表的数据元素通常被存储在一个数组中。**
      **正确答案:** 错  
      **解析:** 链表的数据元素**不存储在数组中**，链表的结点通过指针连接，存储空间可以是分散的。

35. **链式存储方式的特点是存储密度大且插入、删除运算效率高。**
      **正确答案:** 错  
      **解析:** 链式存储的**存储密度小于顺序存储**，因为每个结点除了存储数据外还需要存储指针。但链式存储的插入、删除运算效率高，因为不需要移动其他元素。

# 栈和队列

## 一. 单选题

1. **题目**: 当用一个数组data[0..n-1]存放栈中的元素时，栈底最好（ ）。
   - A. 设置在data[0]处
   - B. 设置在data[n-1]处
   - C. 设置在data[0]或者data[n-1]处
   - D. 设置在data数组的任何位置
     **正确答案**: C
     **解析**: 栈底可以设置在数组的任意一端，通常选择数组的起始位置（data[0]）或末尾位置（data[n-1]），具体取决于实现方式。

2. **题目**: 若一个栈，元素用数组data[1..n]存储，栈空时栈顶指针top为0，则以下元素x出栈最合适的操作是(&nbsp; )。
   - A. x=data[top]; top--;
   - B. x=data[top]; top++;
   - C. top--;x=data[top];
   - D. top++;x=data[top];
     **正确答案**: A
     **解析**: 栈顶指针top指向栈顶元素，出栈时先取出栈顶元素，再将top减1。

3. **题目**: 设固定容量的循环队列的存储空间为a[0..20]，且当前队头指针和队尾指针分别为8和3，则该队列中元素的个数为( )。
   - A. 5
   - B. 6
   - C. 16
   - D. 17
     **正确答案**: C
     **解析**: 循环队列的元素个数计算公式为：(rear - front + maxSize) % maxSize = (3 - 8 + 21) % 21 = 16。

4. **题目**: 若一个栈，元素用数组data[1..n]存储，栈空时栈顶指针top为n，则以下元素x出栈最合适的操作是(&nbsp; )。
   - A. x=data[top]; top++;
   - B. top++;x=data[top];
   - C. x=data[top]; top--;
   - D. top--;x=data[top];
     **正确答案**: B
     **解析**: 栈顶指针top初始为n，表示栈空，出栈时需要先将top加1，再取出栈顶元素。

5. **题目**: 以下几种存储结构中，哪个最适合用作链栈？
   - A. 带头结点的单链表
   - B. 不带头结点的循环单链表
   - C. 带头结点的双链表
   - D. 以上均不适合。
     **正确答案**: A
     **解析**: 带头结点的单链表适合用作链栈，因为头结点可以简化插入和删除操作。

6. **题目**: 有六个元素6,5,4,3,2,1顺序进栈。下列哪一个不是合法的出栈序列?(&nbsp; &nbsp; &nbsp;)
   - A. 5 4 3 6 1 2
   - B. 4 5 3 2 1 6
   - C. 3 4 6 5 2 1
   - D. 2 3 4 1 5 6
     **正确答案**: C
     **解析**: 选项C中，6在5之前出栈，违反了栈的先进后出原则。

7. **题目**: 设顺序循环队列Q[0:M-1]的头指针和尾指针分别为F和R,头指针F总是指向队头元素的前一位置,尾指针R总是指向队尾元素的当前位置,则该循环队列中的元素个数为( )。
   - A. R-F
   - B. F-R
   - C. (R-F+M)%M
   - D. (F-R+M)%M
     **正确答案**: C
     **解析**: 循环队列的元素个数计算公式为：(R - F + M) % M。

8. **题目**: 设n个元素的进栈序列是1，2，3，......，n，其输出序列是<img style="vertical-align: middle; filter: invert(0);" class="ans-latex-moudle" data="%22p_1%2Cp_2%2Cp_3%2C......%2Cp_n%22" src="https://p.ananas.chaoxing.com/star3/origin/fd674246a0b944bb5167b1efd99fe46d.png" data-original="https://p.ananas.chaoxing.com/star3/origin/fd674246a0b944bb5167b1efd99fe46d.png">，若<img style="vertical-align: middle; filter: invert(0);" class="ans-latex-moudle" data="%22p_1%3D3%22" src="https://p.ananas.chaoxing.com/star3/origin/6786475c2bbb08e9859ed8ffca1e24c1.png" data-original="https://p.ananas.chaoxing.com/star3/origin/6786475c2bbb08e9859ed8ffca1e24c1.png">，则<img style="vertical-align: middle; filter: invert(0);" class="ans-latex-moudle" data="%22p_2%22" src="https://p.ananas.chaoxing.com/star3/origin/0e4a577c050fea63c5f8713f4b4351ee.png" data-original="https://p.ananas.chaoxing.com/star3/origin/0e4a577c050fea63c5f8713f4b4351ee.png">的值为(&nbsp; &nbsp; )。
   - A. 一定是2
   - B. 一定是1
   - C. 不可能是1
   - D. 以上都不对
     **正确答案**: C
     **解析**: 由于p1=3，说明1和2仍在栈中，因此p2不可能是1。

9. **题目**: 在循环顺序队列中,假设采用少用一个存储单元的方法来区分队列判空和判满的条件,front和rear分别为队头指针和队尾指针,它们分别指向队首元素和队尾元素的下一个存储单元,队列的最大存储容量为maxSize,则循环顺序队列的长度为( )。
   - A. rear-front
   - B. rear-front+maxSize
   - C. (rear-front)% maxSize
   - D. (rear-front+maxSize)% maxSize
     **正确答案**: D
     **解析**: 循环队列的长度计算公式为：(rear - front + maxSize) % maxSize。

10. **题目**: 算数表达式(a+a*b)*a+c*b/a的后缀表达式为(&nbsp; &nbsp;)。
    - A. aab\*+a\*cb*a/+
    - B. aa\*b+a\*cb*a/+
    - C. aab\*a\*cb*+a/+
    - D. aab\*+acb\*a/+*
      **正确答案**: A
      **解析**: 后缀表达式为：a a b * + a * c b * a / +。

11. **题目**: 输入序列为abcd时，使用栈对其操作，不可能是其输出序列的是（&nbsp; ）。
    - A. acbd
    - B. bcda
    - C. cdba
    - D. dcab
      **正确答案**: D
      **解析**: 选项D中，d在c之前出栈，违反了栈的先进后出原则。

12. **题目**: 将算术表达式“1+6/(8-5)*3”转换成后缀表达式，在后缀表达式求值过程中，当遇到“*”时，运算数栈（从栈顶到栈底的次序）为（&nbsp; ）。
    - A. 8 6 1
    - B. 5 8 1
    - C. 3 2 1
    - D. 3 6 1
      **正确答案**: C
      **解析**: 后缀表达式为：1 6 8 5 - / 3 * +，遇到“*”时，栈顶元素为3和2。

13. **题目**: 若一个栈，元素用数组data[1..n]存储，栈空时栈顶指针top为0，则以下元素进栈最合适的操作是(&nbsp; )。
    - A. top++;x=data[top];
    - B. x=data[top]; top++;
    - C. top--;x=data[top];
    - D. x=data[top]; top--;
      **正确答案**: A
      **解析**: 栈顶指针top初始为0，表示栈空，进栈时需要先将top加1，再放入数据。

14. **题目**: 关于循环队列，下面说法正确的是（ ）。
    - A. 循环队列不会发生溢出。
    - B. 循环队列可以解决假溢出。
    - C. 某循环队列有队首指针front和队尾指针rear，在队不空时出队操作会改变front和rear。
    - D. 某循环队列有队首指针front和队尾指针rear，进队操作为：rear=rear%MaxSize
      **正确答案**: B
      **解析**: 循环队列通过循环利用数组空间，解决了假溢出的问题。

15. **题目**: 在双向循环链表中的p结点之后插入一个新结点s,其修改链的语句顺序是( )。
    - A. <img width="458" height="24" src="https://p.ananas.chaoxing.com/star3/origin/a191aa43aa68158b42a6881b17974c0d.png" data-original="https://p.ananas.chaoxing.com/star3/origin/a191aa43aa68158b42a6881b17974c0d.png" style="filter: invert(0);">
    - B. <img width="448" height="24" src="https://p.ananas.chaoxing.com/star3/origin/0f44da91ccb12a62369e4bc2fa59273d.png" data-original="https://p.ananas.chaoxing.com/star3/origin/0f44da91ccb12a62369e4bc2fa59273d.png" style="filter: invert(0);">
    - C. <img width="453" height="24" src="https://p.ananas.chaoxing.com/star3/origin/65621f0e868cf48a9d26cc43f5fff4e1.png" data-original="https://p.ananas.chaoxing.com/star3/origin/65621f0e868cf48a9d26cc43f5fff4e1.png" style="filter: invert(0);">
    - D. <img width="453" height="24" src="https://p.ananas.chaoxing.com/star3/origin/75fff25232fefba39109f92a95f30ea8.png" data-original="https://p.ananas.chaoxing.com/star3/origin/75fff25232fefba39109f92a95f30ea8.png" style="filter: invert(0);">
      **正确答案**: D
      **解析**: 在双向循环链表中插入新结点s，需要修改p的后继、s的前驱和后继，以及p的后继的前驱。

16. **题目**: 设长度为n的链式队列采用单循环链表加以表示,若只设一个头指针指向队首元素,则入队操作的时间复杂度是( )。
    - A. O(1)
    - B. O(n)
    - C. O(logn)
    - D. <img width="47" height="26" src="https://p.ananas.chaoxing.com/star3/origin/3284b4ac6155f72fc02b0fb43c993f47.png" data-original="https://p.ananas.chaoxing.com/star3/origin/3284b4ac6155f72fc02b0fb43c993f47.png" style="filter: invert(0);">
      **正确答案**: B
      **解析**: 由于只设一个头指针，入队时需要遍历链表找到队尾，时间复杂度为O(n)。

17. **题目**: 已知一个栈的进栈顺序是1，2，3，.....，n,其输出序列的第一个元素是i（1&lt;=i&lt;=n)，则第j（1&lt;=j&lt;=n)个出栈元素是（ ）。
    - A. i
    - B. n-i
    - C. j-i+1
    - D. 不确定
      **正确答案**: D
      **解析**: 由于栈的先进后出特性，第j个出栈元素无法确定，具体取决于进栈和出栈的顺序。

18. **题目**: 当数据采用链式存储结构时，要求（ ）。
    - A. 每个结点占用一片连续的存储区域
    - B. 所有结点占用一片连续的存储区域
    - C. 结点的最后一个数据域是指针类型
    - D. 每个结点不论多少个后继，只需要一个指针域
      **正确答案**: A
      **解析**: 链式存储结构中，每个结点占用一片连续的存储区域，结点之间通过指针链接。

19. **题目**: 设有5个元素的进栈序列是a,b,c,d,e，其输出序列是c,e,d,b,a，则该栈的容量至少是（ ）。
    - A. 1
    - B. 2
    - C. 3
    - D. 4
      **正确答案**: D
      **解析**: 输出序列为c,e,d,b,a，说明栈中最多同时存放4个元素（a,b,d,e），因此栈的容量至少为4。

20. **题目**: 若一个栈元素用数组data[1..n]存储，栈空时（初始栈），栈顶指针top为n，则以下元素x进栈最适合的操作是(&nbsp; )。
    - A. top++;data[top]=x;
    - B. data[top]=x;top++;
    - C. top--;data[top]=x;
    - D. data[top]=x;top--;
      **正确答案**: D
      **解析**: 栈顶指针top初始为n，表示栈空，进栈时需要先将数据放入栈顶，再将top减1。

## 二. 填空题

21. **题目**: 栈的操作遵循<span style="text-decoration: underline;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>原则，<span style="color: rgb(24, 30, 51); font-family: CXChineseQuote, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Segoe UI&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; text-wrap: wrap; background-color: rgb(255, 255, 255);">队列的操作遵循</span><span style="margin: 0px; padding: 0px; color: rgb(24, 30, 51); font-family: CXChineseQuote, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Segoe UI&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; text-wrap: wrap; background-color: rgb(255, 255, 255); text-decoration-line: underline;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="margin: 0px; padding: 0px; color: rgb(24, 30, 51); font-family: CXChineseQuote, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Segoe UI&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;, &quot;Noto Color Emoji&quot;; text-wrap: wrap; background-color: rgb(255, 255, 255);">原则。</span>
    **正确答案**: 
    - (1) 先进后出;后进先出;FILO;LIFO;filo;lifo
    - (2) 先进先出;FIFO;fifo
      **解析**: 栈遵循先进后出（LIFO）原则，队列遵循先进先出（FIFO）原则。

22. **题目**: 当输入序列为1,2,3时,通过栈操作可以得到<span style="text-decoration: underline;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>种不同的序列。
    **正确答案**: 
    - (1) 5
      **解析**: 输入序列为1,2,3时，通过栈操作可以得到5种不同的输出序列：1,2,3；1,3,2；2,1,3；2,3,1；3,2,1。

## 三. 判断题

23. **题目**: 在链栈中,进行入栈操作时,不需要判断栈是否已满。
    **正确答案**: 对
    **解析**: 链栈的存储空间是动态分配的，因此不需要判断栈是否已满。

24. **题目**: 栈和队列都是线性结构。
    **正确答案**: 对
    **解析**: 栈和队列都是线性数据结构，栈是先进后出，队列是先进先

# 树和二叉树

## 一. 单选题

1. **题目**: 一棵有300个结点的二叉树，至少有(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )层。
   - A. 7
   - B. 6
   - C. 9
   - D. 8
     **正确答案**: C
     **解析**: 根据二叉树的性质，满二叉树的结点数为 \(2^h - 1\)，其中 \(h\) 为层数。当 \(h=8\) 时，满二叉树的结点数为 \(2^8 - 1 = 255\)，而题目中有300个结点，因此至少需要9层。

2. **题目**: 一棵完全二叉树中有501个叶子结点，则最多有(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )个结点。
   - A. 501
   - B. 1001
   - C. 1002
   - D. 502
     **正确答案**: C
     **解析**: 完全二叉树的叶子结点数为501，根据二叉树的性质，叶子结点数 \(n_0 = n_2 + 1\)，因此度为2的结点数 \(n_2 = 500\)。完全二叉树的结点总数为 \(n_0 + n_1 + n_2\)，其中 \(n_1\) 为度为1的结点数，最多为1，因此结点总数为 \(501 + 1 + 500 = 1002\)。

3. **题目**: 一棵二叉树中有35个结点，其中所有结点度之和是(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)
   - A. 35
   - B. 16
   - C. 34
   - D. 33
     **正确答案**: C
     **解析**: 二叉树中所有结点的度之和等于结点数减1，即 \(35 - 1 = 34\)。

4. **题目**: 如果一棵二叉树B是由一棵树T转换而来的，那么T中结点的先根遍历结果对应与B的(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )结果。
   - A. 后根遍历
   - B. 先根遍历
   - C. 中根遍历
   - D. 层次遍历
     **正确答案**: B
     **解析**: 树T的先根遍历结果与二叉树B的先根遍历结果一致。

5. **题目**: 深度为h的二叉树最多具有结点个数为(&nbsp; )。
   - A. \(2^h - 1\)
   - B. \(2^h\)
   - C. \(2^{h-1} - 1\)
   - D. \(2^{h-1}\)
     **正确答案**: A
     **解析**: 深度为h的满二叉树最多具有 \(2^h - 1\) 个结点。

6. **题目**: 以下哪个不属于树形结构的范畴?
   - A. 家谱
   - B. Windows的文件管理系统
   - C. 某班级学生名册
   - D. 单位组织结构
     **正确答案**: C
     **解析**: 某班级学生名册是线性结构，不属于树形结构。

7. **题目**: 一棵高度为8的完全二叉树，至少有(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )个叶子结点。
   - A. 127
   - B. 128
   - C. 63
   - D. 64
     **正确答案**: D
     **解析**: 完全二叉树的最少叶子结点数为 \(2^{h-1}\)，其中 \(h\) 为高度。当 \(h=8\) 时，最少叶子结点数为 \(2^{7} = 128\)。

8. **题目**: 树最适合用来表示()
   - A. 元素之间具有分支层次关系的数据
   - B. 无序数据元素
   - C. 元素之间无联系的数据
   - D. 有序数据元素
     **正确答案**: A
     **解析**: 树最适合表示具有分支层次关系的数据。

9. **题目**: 具有10个叶子结点的二叉树中有(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)个度为2的结点。
   - A. 9
   - B. 11
   - C. 10
   - D. 8
     **正确答案**: A
     **解析**: 根据二叉树的性质，叶子结点数 \(n_0 = n_2 + 1\)，因此度为2的结点数 \(n_2 = n_0 - 1 = 9\)。

10. **题目**: 在哈夫曼树中，分支结点的度数(&nbsp;&nbsp;&nbsp;&nbsp;)。
    - A. 不确定
    - B. 可以是1或者2
    - C. 只能是1或2
    - D. 都为2
      **正确答案**: D
      **解析**: 哈夫曼树中分支结点的度数都为2。

11. **题目**: 5个字符有如下4种编码方案，不是前缀码的是（&nbsp; ）。
    - A. 0，100,110,1110,1100
    - B. 01,0000,0001,001,1
    - C. 011,000,001,010,1
    - D. 000,001,010,011,100
      **正确答案**: A
      **解析**: 前缀码要求任何一个字符的编码都不是另一个字符编码的前缀。选项A中，110是1100的前缀，因此不是前缀码。

12. **题目**: 高度为5的二叉树最多有(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )个结点。
    - A. 32
    - B. 16
    - C. 10
    - D. 31
      **正确答案**: D
      **解析**: 高度为5的满二叉树最多具有 \(2^5 - 1 = 31\) 个结点。

13. **题目**: 若一棵3次树中，有两个度为3的结点，一个度为2的结点，两个度为1的结点，则该树一共有(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )个结点。
    - A. 5
    - B. 10
    - C. 8
    - D. 11
      **正确答案**: D
      **解析**: 树的结点数等于所有结点的度数之和加1，即 \(2 \times 3 + 1 \times 2 + 2 \times 1 + 1 = 11\)。

14. **题目**: 设森林F中有3棵树，第一，第二，第三棵树的结点个数分别为9，8，7，则与森林F对应的二叉树根结点的右子树上的结点个数是(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)。
    - A. 15
    - B. 16
    - C. 7
    - D. 17
      **正确答案**: A
      **解析**: 森林转换为二叉树后，根结点的右子树上的结点个数为第二和第三棵树的结点数之和，即 \(8 + 7 = 15\)。

15. **题目**: 一棵满二叉树中有127个结点，其中叶子结点的个数是(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)。
    - A. 66
    - B. 65
    - C. 64
    - D. 63
      **正确答案**: C
      **解析**: 满二叉树的叶子结点数为 \(2^{h-1}\)，其中 \(h\) 为高度。当结点数为127时，高度为7，叶子结点数为 \(2^{6} = 64\)。

16. **题目**: 若某二叉树的后序遍历序列为DBEFCA，中根遍历序列为DBAECF，则这棵二叉树的先序遍历序列为(&nbsp; &nbsp; )。
    - A. ABCDEF
    - B. ABDCEF
    - C. ABCDFE
    - D. ABDECF
      **正确答案**: B
      **解析**: 根据后序遍历和中序遍历可以构造出二叉树，先序遍历结果为ABDCEF。

17. **题目**: 二叉树第i层上最多有(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )个结点。
    - A. \(2^{i-1}\)
    - B. \(2^i\)
    - C. \(2^{i+1}\)
    - D. \(2^{i-2}\)
      **正确答案**: A
      **解析**: 二叉树的第i层最多有 \(2^{i-1}\) 个结点。

18. **题目**: 一棵高度为h的满二叉树共有n个结点，其中叶子结点有m个，则以下关系中正确的是(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )。
    - A. h+m=2n
    - B. n=h+m
    - C. n=2m-1
    - D. m=h-1
      **正确答案**: C
      **解析**: 满二叉树的叶子结点数 \(m = 2^{h-1}\)，结点数 \(n = 2^h - 1\)，因此 \(n = 2m - 1\)。

19. **题目**: 设某棵二叉树的中序遍历序列为ABCD，前序（先序）遍历序列为CABD,，则后序遍历该二叉树得到序列为(&nbsp; &nbsp; )。
    - A. BCDA
    - B. CBDA
    - C. BADC
    - D. CDAB
      **正确答案**: C
      **解析**: 根据先序遍历和中序遍历可以构造出二叉树，后序遍历结果为BADC。

20. **题目**: 设哈夫曼树中的叶子结点总数为m，若用二叉链表作为存储结构，则该哈夫曼树中总共有(&nbsp;&nbsp;&nbsp;&nbsp; )个空指针域。
    - A. 2m
    - B. 4m
    - C. 2m-1
    - D. 2m+1
      **正确答案**: A
      **解析**: 哈夫曼树中只有度为0和度为2的结点，度为0的结点有2个空指针域，因此总空指针域为 \(2m\)。

21. **题目**: 对于一棵有n个结点的满二叉树，其中叶子结点有m个，深度为h，则(&nbsp; &nbsp; &nbsp;)。
    - A. n=h+m
    - B. h+m=2n
    - C. m=h-1
    - D. n=2^h-1
      **正确答案**: D
      **解析**: 满二叉树的结点数 \(n = 2^h - 1\)。

22. **题目**: 深度为6(根结点处于第1层)的二叉树最多有(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )个结点。
    - A. 32
    - B. 64
    - C. 63
    - D. 31
      **正确答案**: C
      **解析**: 深度为6的满二叉树最多具有 \(2^6 - 1 = 63\) 个结点。

23. **题目**: 一棵度为5，结点个数为n的树采用孩子链存储结构时，其中空指针的个数为(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )。
    - A. 4n
    - B. 4n+1
    - C. 5n
    - D. 4n-1
      **正确答案**: B
      **解析**: 度为5的树采用孩子链存储结构时，空指针的个数为 \(5n - (n - 1) = 4n + 1\)。

## 二. 填空题

24. **题目**: 一棵含有999个结点的完全二叉树的深度为____。
    **正确答案**: 10
    **解析**: 完全二叉树的深度为 \(\lceil \log_2(999 + 1) \rceil = 10\)。

25. **题目**: 有20个结点的完全二叉树中,根结点在第1层,第4层有____个结点。
    **正确答案**: 8
    **解析**: 完全二叉树的第4层最多有 \(2^{3} = 8\) 个结点。

26. **题目**: 在有n个结点的二叉树的二叉链表存储结构中有____个空的指针域。
    **正确答案**: n+1
    **解析**: 二叉链表存储结构中，空指针域的个数为 \(n + 1\)。

27. **题目**: 一棵有n个叶结点的哈夫曼树共有____个结点。
    **正确答案**: 2n-1
    **解析**: 哈夫曼树的结点总数为 \(2n - 1\)。

28. **题目**: 一棵具有100个结点的完全二叉树,其叶结点个数为____。
    **正确答案**: 50
    **解析**: 完全二叉树的叶子结点数为 \(\lceil \frac{100}{2} \rceil = 50\)。

29. **题目**: 已知完全二叉树的第8层有8个结点,则其叶子结点总数有____个。
    **正确答案**: 68
    **解析**: 完全二叉树的第7层有 \(2^{6} = 64\) 个结点，第8层有8个结点，因此叶子结点总数为 \(64 - 4 + 8 = 68\)。

## 三. 判断题

30. **题目**: 一棵二叉树的先序遍历序列和后序遍历序列可以唯一决定一棵二叉树。
    **正确答案**: 错
    **解析**: 必须有中序遍历序列才能唯一确定一棵二叉树。

31. **题目**: 二叉树是度为2的树。
    **正确答案**: 错
    **解析**: 二叉树的度可以为0、1或2，不一定是度为2的树。

32. **题目**: 满二叉树一定是完全二叉树。
    **正确答案**: 对
    **解析**: 满二叉树是完全二叉树的一种特殊情况。

33. **题目**: 二叉树是有序树。
    **正确答案**: 对
    **解析**: 二叉树严格区分左右子树，是有序树。

34. **题目**: 将一棵树转化为一棵二叉树，则这棵二叉树没有右子树。
    **正确答案**: 对
    **解析**: 树转换为二叉树后，根结点没有右子树。

35. **题目**: 完全二叉树的n个结点与一棵同样高度的满二叉树的前n个结点在位置上一一对应。
    **正确答案**: 对
    **解析**: 完全二叉树的结点位置与满二叉树的前n个结点位置一一对应。

36. **题目**: 完全二叉树中的叶子结点只能在最下面的两层中出现。
    **正确答案**: 对
    **解析**: 完全二叉树的叶子结点只能出现在最下面两层。

37. **题目**: 完全二叉树一定是满二叉树。
    **正确答案**: 错
    **解析**: 完全二叉树不一定是满二叉树，满二叉树是完全二叉树的特殊情况。

38. **题目**: 二叉树即度不超过2的树。
    **正确答案**: 错
    **解析**: 二叉树的度可以为0、1或2，但不仅仅是度不超过2的树。

# 查找

## 一. 单选题

1. **在长度为n的线性表中顺序查找，成功情况下最多比较次数是( )。**
   - A. n
   - B. (n+1)/2
   - C. n/2
   - D. 1
     **正确答案:** A  
     **解析:** 顺序查找在最坏情况下需要比较所有元素，因此最多比较次数为n。

2. **设待查关键字为47，且已存入变量k中，如果在查找过程中和k进行比较的元素依次是47，32，46，25，47，则所采用的查找方法是( )。**
   - A. 可能是分块查找
   - B. 一种错误的方法
   - C. 可能是顺序查找
   - D. 可能是折半查找
     **正确答案:** A  
     **解析:** 先与47比较过，说明选择了最大值为47的块，再进入块中进行顺序查找。

3. **从19个元素的序列中查找其中某个元素，如果最多进行5次元素之间的比较，则采用的查找方法只可能是( )。**
   - A. 折半查找
   - B. 顺序查找
   - C. 分块查找
   - D. 二叉排序树查找
     **正确答案:** A  
     **解析:** 折半查找的时间复杂度为O(log n)，对于19个元素，最多需要5次比较。

4. **对于下列关键字序列，不可能构成某二叉排序树中一条查找路径的是( )。**
   - A. 12，25，71，68，33，34
   - B. 21，89，77，29，36，38
   - C. 95，22，91，24，94，71
   - D. 92，20，91，34，88，35
     **正确答案:** C  
     **解析:** 关于序列95，22，91，24，94，71，构造出二叉排序树。二叉排序树的查找路径是从根结点到某结点的路径，A的比较轨迹为：待查关键字小于95，沿左分支到22，又大于22，沿右分支到91，再小于91，沿左分支到24，如果比91小又比24大，只可能走24的右分支，是不会走到94那边去，因此不可能。

5. **在任一一棵非空二叉排序树T1中，删除某结点v之后形成二叉排序树T2，再将v插入T2形成二叉排序树T3。下列关于T1和T3的叙述中正确的是( )。**

  - I. 若v是T1的叶子结点，则T1与T3不同
  - II. 若v是T1的叶子结点，则T1与T3相同
  - III. 若v不是T1的叶子结点，则T1与T3不同
  - IV. 若v不是T1的叶子结点，则T1与T3相同
    **选项：**
  - A. 仅II和III
  - B. 仅I和III
  - C. 仅II和IV
  - D. 仅I和IV
    **正确答案:** A
    **解析:**
  - **若v是T1的叶子结点**：删除v后再插入v，树的结构不会改变，因此T1与T3相同（II正确）。
  - **若v不是T1的叶子结点**：删除v后可能会改变树的结构，再插入v时，v的位置可能发生变化，因此T1与T3不同（III正确）。
    综上，仅II和III正确。
  - 或画图分析。二叉排序树：根大于左孩子，根小于右孩子。

6. **一棵二叉排序树是由关键字集合{18，43，27，77，44，36，39}中的某个关键字序列构建的，其中序遍历序列是( )。**
   - A. 18，43，27，77，44，36，39
   - B. 18，27，36，39，43，44，77
   - C. 18，44，43，39，36，27，77
   - D. 无法确定
     **正确答案:** B  
     **解析:** 所给序列构造的二叉排序树为：再中序遍历。

7. **由一个关键字序列建立一棵二叉排序树，该二叉排序树的形状取决于( )。**
   - A. 序列中关键字的取值范围
   - B. 使用的计算机软、硬件条件
   - C. 关键字的输入次序
   - D. 该序列的存储结构
     **正确答案:** C  
     **解析:** 不同关键字序列，产生的二叉排序树不同。

8. **设带查找关键字为47，且已存入变量k中，如果在查找过程中和k进行比较的元素依次是27，72，16，84，47，则所采用的查找方法是( )。**
   - A. 顺序查找
   - B. 分块查找
   - C. 折半查找
   - D. 二叉排序树查找
     **正确答案:** A  
     **解析:** 所比较的数是无序的，所以是顺序逐个比较。

9. **对线性表进行折半（二分）查找时,要求线性表必须( )。**
   - A. 以顺序方式存储，且结点按关键字有序排列
   - B. 以链式方式存储
   - C. 以链式方式存储，且结点按关键字有序排列
   - D. 以顺序方式存储
     **正确答案:** A  
     **解析:** 折半查找要求线性表必须顺序存储且有序。

10. **在哈希表查找过程中可用( )来处理冲突。**
    - A. 线性探测法
    - B. 除留余数法
    - C. 数字分析法
    - D. 关键字比较法
      **正确答案:** A  
      **解析:** 线性探测法是处理哈希冲突的一种方法。

11. **在长度为n的线性表中顺序查找，不成功时的平均比较次数是( )。**
    - A. (n-1)/2
    - B. (n+1)/2
    - C. n/2
    - D. n
      **正确答案:** D  
      **解析:** 顺序查找不成功时需要比较所有元素，因此平均比较次数为n。

12. **一个长度为12的有序表R[0..11]，按折半查找法对该表进行查找，在表内各元素等概率情况下查找不成功所需的平均比较次数为( )。**
    - A. 35/11
    - B. 37/12
    - C. 49/12
    - D. 49/13
      **正确答案:** D  
      **解析:** 可以用判定树来求解，参考第9章PPT的P18，注意PPT的元素是[0..10]11个元素,本题是[0..11]12个元素。

13. **对于有序表(1，3，9，12，32，41，45，62，75，77，82，95，99)，当采用折半查找法查找关键字为82的元素使，( )次比较后查找成功。**
    - A. 8
    - B. 2
    - C. 1
    - D. 4
      **正确答案:** D  
      **解析:** 参考第9章例9.4，画出具体的判定树，每个结点即为 mid位置的数据。

14. **一个长度为12的有序表R[0..11]，按折半查找法对该表进行查找，在表内各元素等概率情况下查找成功所需的平均比较次数为( )。**
    - A. 39/12
    - B. 35/12
    - C. 43/12
    - D. 37/12
      **正确答案:** D  
      **解析:** 可以用判定树来求解，参考第9章PPT的P18，注意PPT的元素是[0..10]11个元素,本题是[0..11]12个元素。

15. **设有100个元素的有序顺序表，采用折半查找，不成功时，最大的比较次数为( )。**
    - A. 10
    - B. 7
    - C. 25
    - D. 50
      **正确答案:** B  
      **解析:** 第9章PPT的P26

## 二. 填空题

16. **具有12个关键字的有序表，二分查找的平均查找长度为________。（结果保留1位小数）**
    **正确答案:** 3.1  
    **解析:** 平均查找长度是指：等概率情况下查找成功的平均比较次数。下图为12个元素，查找成功即为 37/12 约为3.1

17. **____遍历一棵二叉排序树可以得到一个有序序列。**
    **正确答案:** 中序;中根  
    **解析:** 中序遍历二叉排序树可以得到一个有序序列。

## 三. 判断题

18. **二分查找要求序列顺序存储并且关键字序列有序。**
    **正确答案:** 对  
    **解析:** 二分查找要求序列必须顺序存储且有序。

19. **顺序查找是指在顺序表上进行查找的方法。**
    **正确答案:** 错  
    **解析:** 顺序查找不仅限于顺序表，也可以在链表等其他结构上进行。

# 排序

## 一. 单选题

1. **用某种排序方法堆关键字序列(25，84，21，47，15，27，68，35，20)进行升序排序，序列的变化情况如下:**  
   20，15，21，25，47，27，68，35，84  
   15，20，21，25，35，27，47，68，84  
   15，20，21，25，27，35，47，68，84  
   **这样的排序序列变化符合下面哪个选项？（&nbsp; &nbsp;）**  
   - A. 归并排序  
   - B. 希尔排序  
   - C. 快速排序  
   - D. 选择排序  
     **正确答案:** C  
     **解析:** 根据各排序思想来判断，快速排序的特点是每次选择一个基准元素，将序列分为两部分，符合题目中的变化情况。

2. **在下列排序方法中，(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )在最后一趟排序结束之前可能所有元素都没有放到其最终位置上。**  
   - A. 堆排序  
   - B. 希尔排序  
   - C. 冒泡排序  
   - D. 简单选择排序  
     **正确答案:** B  
     **解析:** 希尔排序通常最后还需要进行一次直接插入排序，因此在最后一趟之前，元素可能还未放到最终位置。

3. **快速排序算法的平均时间复杂度为(&nbsp; &nbsp; &nbsp; &nbsp;), 直接插入排序算法的平均时间复杂度为(&nbsp; &nbsp; &nbsp; )。**  
   - A. <img src="https://p.ananas.chaoxing.com/star3/origin/da96f459ddb04699ae0a217a7a55cd22.png" class="ans-ued-img" width="70" height="39" title="" alt="" style="text-wrap: wrap; width: 70px; height: 39px; filter: invert(0);" data-original="https://p.ananas.chaoxing.com/star3/origin/da96f459ddb04699ae0a217a7a55cd22.png">,<img src="https://p.ananas.chaoxing.com/star3/origin/da96f459ddb04699ae0a217a7a55cd22.png" class="ans-ued-img" width="70" height="39" title="" alt="" style="text-wrap: wrap; width: 70px; height: 39px; filter: invert(0);" data-original="https://p.ananas.chaoxing.com/star3/origin/da96f459ddb04699ae0a217a7a55cd22.png">  
   - B. <img src="https://p.ananas.chaoxing.com/star3/origin/da96f459ddb04699ae0a217a7a55cd22.png" class="ans-ued-img" width="70" height="39" title="" alt="" style="text-wrap: wrap; width: 70px; height: 39px; filter: invert(0);" data-original="https://p.ananas.chaoxing.com/star3/origin/da96f459ddb04699ae0a217a7a55cd22.png">,<img src="https://p.ananas.chaoxing.com/star3/origin/c6132b606a45a2d5dd267b17e26aba0a.png" class="ans-ued-img" width="60" height="37" title="" alt="" style="text-wrap: wrap; width: 60px; height: 37px; filter: invert(0);" data-original="https://p.ananas.chaoxing.com/star3/origin/c6132b606a45a2d5dd267b17e26aba0a.png">  
   - C. <img src="https://p.ananas.chaoxing.com/star3/origin/d7612e4d2d55edea88b522aaca8eded8.png" class="ans-ued-img" width="100" height="37" title="" alt="" style="width: 100px; height: 37px; filter: invert(0);" data-original="https://p.ananas.chaoxing.com/star3/origin/d7612e4d2d55edea88b522aaca8eded8.png">,&nbsp; &nbsp; &nbsp;<img src="https://p.ananas.chaoxing.com/star3/origin/c6132b606a45a2d5dd267b17e26aba0a.png" class="ans-ued-img" width="60" height="37" title="" alt="" style="width: 60px; height: 37px; filter: invert(0);" data-original="https://p.ananas.chaoxing.com/star3/origin/c6132b606a45a2d5dd267b17e26aba0a.png">  
   - D. <img src="https://p.ananas.chaoxing.com/star3/origin/d7612e4d2d55edea88b522aaca8eded8.png" class="ans-ued-img" width="100" height="37" title="" alt="" style="text-wrap: wrap; width: 100px; height: 37px; filter: invert(0);" data-original="https://p.ananas.chaoxing.com/star3/origin/d7612e4d2d55edea88b522aaca8eded8.png"><span style="text-wrap: wrap;">,&nbsp; &nbsp; &nbsp;</span><img src="https://p.ananas.chaoxing.com/star3/origin/da96f459ddb04699ae0a217a7a55cd22.png" class="ans-ued-img" width="70" height="39" title="" alt="" style="width: 70px; height: 39px; filter: invert(0);" data-original="https://p.ananas.chaoxing.com/star3/origin/da96f459ddb04699ae0a217a7a55cd22.png">  
     **正确答案:** D  
     **解析:** 快速排序的平均时间复杂度为 \(O(n \log n)\)，直接插入排序的平均时间复杂度为 \(O(n^2)\)。

4. **设一组初始记录关键字序列(5,2,6,3,8),以第一个记录关键字5为基准进行一趟快速排序的结果为(&nbsp; &nbsp;)。**  
   - A. 3,2,5,6,8  
   - B. 2,3,5,8,6  
   - C. 3,2,5,8,6  
   - D. 2,3,6,5,8  
     **正确答案:** A  
     **解析:** 快速排序的第一趟以5为基准，将小于5的元素放在左边，大于5的元素放在右边，结果为3,2,5,6,8。

5. **在以下4个线性表中，最适合采用基数排序的是(&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)。**  
   - A. 10000个100以内的正整数  
   - B. 10000个实数  
   - C. 1000个由字母、数字和其他字符组成的字符串  
   - D. 1000个int类型的整数  
     **正确答案:** A  
     **解析:** 基数排序适合那些便于按位分配的数据序列，因此100以内的正整数最适合。

6. **在一般情况下，以下排序算法中元素移动次数最少的是(&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)。**  
   - A. 冒泡排序  
   - B. 都一样  
   - C. 直接插入排序  
   - D. 简单选择排序  
     **正确答案:** D  
     **解析:** 简单选择排序的基本思想是从无序区中选出当前最小的元素，放入有序区末尾，因此移动次数最少。

7. **下列排序算法中,在待排序数据已有序时（正序）,那么正序排序花费时间最少的是(&nbsp; &nbsp; )排序。**  
   - A. 快速排序  
   - B. 直接插入排序  
   - C. 冒泡排序  
   - D. 简单选择排序  
     **正确答案:** B  
     **解析:** 基本有序时，直接插入排序省了比较时间，也省了交换时间。

8. **有一个整数序列为(15，9，7，8，20，-1，7，4)，用堆排序的筛选方法建立的初始堆为(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)。**  
   - A. (-1，4，7，8，20，15，7，9)  
   - B. (-1，7，15，7，4，8，20，9)  
   - C. (-1，4，8，9，20，7，15，7)  
   - D. 以上都不对  
     **正确答案:** A  
     **解析:** 堆排序的初始堆建立过程是将序列调整为小根堆，结果为(-1，4，7，8，20，15，7，9)。

9. **数据序列(8，9，10，4，5，6，20，1，2)只能是(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)算法两趟排序后的结果。**  
   - A. 直接插入排序  
   - B. 冒泡排序  
   - C. 简单选择排序  
   - D. 堆排序  
     **正确答案:** A  
     **解析:** 直接插入排序的特点是每次将一个元素插入到已排序的序列中，符合题目中的变化情况。

10. **关键字序列(8,9,10,4,5,6,20,1,2)是下列排序算法中(&nbsp;&nbsp;&nbsp;&nbsp;)的升序排序，两趟排序后的结果。**  
    - A. 堆排序  
    - B. 冒泡排序  
    - C. 插入排序  
    - D. 选择排序  
      **正确答案:** C  
      **解析:** 直接插入排序的特点是每次将一个元素插入到已排序的序列中，符合题目中的变化情况。

11. **对一组数据(2，12，16，88，5，10)进行排序，若前3趟的结果如下:**  
    第1趟:2，12，16，5，10，88  
    第2趟:2，12，5，10，16，88  
    第3趟:2，5，10，12，16，88  
    **则采用的排序方法可能是(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)。**  
    - A. 冒泡排序  
    - B. 希尔排序  
    - C. 二路归并排序  
    - D. 基数排序  
      **正确答案:** A  
      **解析:** 冒泡排序的特点是每次将最大的元素“冒”到最后，符合题目中的变化情况。

12. **快速排序的最坏时间复杂度为（&nbsp; &nbsp; &nbsp;）。**  
    - A. <img src="https://p.ananas.chaoxing.com/star3/origin/c6132b606a45a2d5dd267b17e26aba0a.png" class="ans-ued-img" width="60" height="37" title="" alt="" style="width: 60px; height: 37px; filter: invert(0);" data-original="https://p.ananas.chaoxing.com/star3/origin/c6132b606a45a2d5dd267b17e26aba0a.png"><br>  
    - B. <img src="https://p.ananas.chaoxing.com/star3/origin/d7612e4d2d55edea88b522aaca8eded8.png" class="ans-ued-img" width="80" height="28" title="" alt="" style="width: 80px; height: 28px; filter: invert(0);" data-original="https://p.ananas.chaoxing.com/star3/origin/d7612e4d2d55edea88b522aaca8eded8.png"><br>  
    - C. <img src="https://p.ananas.chaoxing.com/star3/origin/9c60dabb06963610d6cf976a73bdf693.png" class="ans-ued-img" width="80" height="31" title="" alt="" style="width: 80px; height: 31px; filter: invert(0);" data-original="https://p.ananas.chaoxing.com/star3/origin/9c60dabb06963610d6cf976a73bdf693.png"><br>  
    - D. <img src="https://p.ananas.chaoxing.com/star3/origin/da96f459ddb04699ae0a217a7a55cd22.png" class="ans-ued-img" width="60" height="33" title="" alt="" style="width: 60px; height: 33px; filter: invert(0);" data-original="https://p.ananas.chaoxing.com/star3/origin/da96f459ddb04699ae0a217a7a55cd22.png"><br>  
      **正确答案:** D  
      **解析:** 快速排序的最坏时间复杂度为 \(O(n^2)\)。

13. **整数序列(5，4，15，10，3，2，9，6，1)是某排序方法第1趟排序后的结果，该排序方法可能是(&nbsp; &nbsp; &nbsp; &nbsp; )。**  
    - A. 堆排序  
    - B. 冒泡排序  
    - C. 二路归并排序  
    - D. 简单选择排序  
      **正确答案:** C  
      **解析:** 二路归并排序的特点是每次将序列分为两部分进行排序，符合题目中的变化情况。

14. **对于有n个元素的顺序表进行直接插入排序，在最坏情况下需比较(&nbsp;&nbsp;&nbsp;&nbsp;)次。**  
    - A. n(n-1)/2  
    - B. n-1  
    - C. n/2  
    - D. n+1  
      **正确答案:** A  
      **解析:** 直接插入排序在最坏情况下需要比较 \(n(n-1)/2\) 次。

15. **对整数序列(8，9，10，4，5，6，20，1，2)进行递增排序，采用每趟冒出一个最小元素的冒泡排序算法，需要进行的趟数是(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)。**  
    - A. 4  
    - B. 3  
    - C. 6  
    - D. 8  
      **正确答案:** D  
      **解析:** 冒泡排序需要进行 \(n-1\) 趟，其中 \(n\) 为序列长度。

16. **对同一待排序序列分别进行折半插入排序和直接插入排序，两者之间可能的不同之处是(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)。**  
    - A. 排序的总趟数  
    - B. 元素的移动次数  
    - C. 元素之间的比较次数  
    - D. 使用辅助空间的数量  
      **正确答案:** C  
      **解析:** 折半插入排序通过二分查找减少比较次数，但移动次数和直接插入排序相同。

17. **从2^n个不同的元素中选择最小元素所需的关键字比较次数最少是(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )次。**  
    - A. n-1  
    - B. 2^n  
    - C. n  
    - D. 2^n-1  
      **正确答案:** D  
      **解析:** 选择最小元素需要进行 \(2^n-1\) 次比较。

18. **对给定的关键字序列(110，119，007，911，114，120，122)进行基数排序，则第2趟分配收集后得到的关键字序列是(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )。**  
    - A. 007，110，119，114，911，122，120  
    - B. 110，120，911，122，114，007，119  
    - C. 007，110，911，114，119，120，122  
    - D. 007，110，119，114，911，120，122  
      **正确答案:** C  
      **解析:** 基数排序的第2趟按十位分配和收集后，序列为007，110，911，114，119，120，122。

19. **在下列排序算法中，(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )在一趟结束后不一定能选出一个元素放在其最终位置上。**  
    - A. 堆排序  
    - B. 二路归并排序  
    - C. 简单选择排序  
    - D. 冒泡排序  
      **正确答案:** B  
      **解析:** 二路归并排序在一趟结束后不一定能选出一个元素放在其最终位置上。

20. **在以下排序方法中，(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )在初始序列已经基本有序（正序）的情况下排序效率最高。**  
    - A. 冒泡排序  
    - B. 堆排序  
    - C. 快速排序  
    - D. 直接插入排序  
      **正确答案:** D  
      **解析:** 直接插入排序在基本有序的情况下，时间复杂度接近 \(O(n)\)。

21. **在以下排序方法中，(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)不需要进行关键字的比较。**  
    - A. 快速排序  
    - B. 二路归并排序  
    - C. 基数排序  
    - D. 堆排序  
      **正确答案:** C  
      **解析:** 基数排序通过分配和收集进行排序，不需要进行关键字比较。

22. **对8个元素的顺序表进行快速排序，在最好情况下元素之间的比较次数为(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )次。**  
    - A. 12  
    - B. 13  
    - C. 8  
    - D. 7  
      **正确答案:** B  
      **解析:** 快速排序在最好情况下，比较次数为 \(13\) 次。

## 二. 填空题

23. **设有一组初始关键字序列为(24,35,12,27,18,26),则第3趟简单选择排序结束后第5个数是<span style="text-decoration: underline;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>。**  
      **正确答案:** 35  
      **解析:** 第3趟简单选择排序后，序列为12,18,24,27,35,26，第5个数为35。

24. **对一组序列(50,40,95,20,15,70,60,48,80)进行直接插入排序时,当把第7个元素60插入到有序表中时,为寻找插入位置需比较____次。**  
      **正确答案:** 3  
      **解析:** 插入60时，依次与95、70和50比较，共比较3次。

25. **在对序列(50,40,95,20,15,70,60,45,80)进行选择排序时,第4次交换和选择后,第5个数为<span style="text-decoration: underline;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>。**  
      **正确答案:** 50  
      **解析:** 第4次选择排序后，序列为15,20,40,45,50,70,60,95,80，第5个数为50。

## 三. 判断题

26. **直接插入排序算法是稳定的。**  
      **正确答案:** 对  
      **解析:** 直接插入排序是稳定的排序算法。

27. **二路合并时，被合并的两个子序列必须有相同的关键字数量。**  
      **正确答案:** 错  
      **解析:** 二路归并排序时，两个子序列的长度可以不同。

28. **一个序列的排序时间复杂度取决于该序列中逆序对的数量。**  
      **正确答案:** 错  
      **解析:** 排序时间复杂度取决于算法本身，而不是逆序对的数量。
